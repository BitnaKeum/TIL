
## 구조체

- 구조체가 존재하진 않지만, @dataclass 데코레이션과 class를 이용해 만들 수 있다 _(Python 3.7부터)_

```
from dataclasses import dataclass

@dataclass
class Person:
  name: str = None
  age: int = None
```
```
bitna = Person("bitna", 24)
```

<br><br><br>

## 스택(Stack)
- 스택 자료형이 존재하진 않지만, 리스트로 모든 연산이 가능하다
- 

<br><br><br>

## 큐(Queue)
- 큐 자료형이 존재하진 않지만, 리스트로 모든 연산이 가능하다

<br><br><br>

## 검색 알고리즘

#### 선형 검색
- 리스트의 맨 앞부터 특정 데이터를 찾을 때, 매번 2가지 조건 확인이 필요 -> 비용 up
  - 조건1> 현재 값이 찾는 값인가?
  - 조건2> 검색할 값을 찾지 못해 배열의 끝을 지났는가?
- 보초법
  - 리스트 맨 끝에 검색할 값을 추가한 다음 검색을 진행
  - 매번 1가지 조건 확인이 필요 -> 비용 down
    - 조건1> 현재 값이 찾는 값인가?
  - 검색할 값을 찾았으면 그 값의 인덱스가 원래 리스트의 길이와 같은지 확인
    - 같으면 값이 존재하지 않는 것 
<br>

#### 이진 검색
- 정렬된 리스트에서 사용 가능
- 매우 효율적
- 종료 조건 : 검색할 값을 찾지 못해 오른쪽 범위가 왼쪽 범위보다 작아진 경우

<br>

#### 해시법
- 해시값 구하기
  - 키(원소 값)가 int형일 때-> 해시테이블의 크기로 나눈 나머지 _ex) 키: 7, 해시테이블 크기: 5 => 해시값: 2_
  - 키가 int형이 아닐 때 -> 표준 라이브러리를 이용해 형 변환 후 해시테이블의 크기로 나눈 나머지 <br>
  _ex)_ `int(hashlib.sha256(str(키).encode()).hexdigest(), 16) % 해시테이블 크기`
  
  
- 해시 충돌 : 해시테이블에 이미 해당 해시값을 갖는 원소가 있는 경우
  - 해결 방법1> 체인법(오픈 해시법) : 해시값이 같은 원소들을 연결 리스트로 관리
  - 해결 방법2> 오픈 주소법 : 다른 빈 버킷을 찾을 때까지 반복


- 체인법
  - search() 함수 구현

         1. 검색하려는 키를 해시 함수를 이용해 해시값으로 변환
         2. 해시테이블에서 해당 해시값을 인덱스로 하는 버킷을 주목
         3. 버킷이 참조하는 연결 리스트를 맨 앞부터 스캔(선형 검색)함
    => 키와 같은 값을 찾으면 검색 성공, 못 찾으면 검색 실패

  - add() 함수 구현
  
        1. 추가하려는 키를 해시 함수를 이용해 해시값으로 변환
        2. 해시테이블에서 해당 해시값을 인덱스로 하는 버킷을 주목
        3. 버킷이 참조하는 연결 리스트를 맨 앞부터 스캔함
    => 키와 같은 값이 있으면 추가 실패(이미 있는 값이므로), 없으면 연결 리스트의 맨 앞에 노드 추가

  - remove() 함수 구현
  
        1. 삭제하려는 키를 해시 함수를 이용해 해시값으로 변환
        2. 해시테이블에서 해당 해시값을 인덱스로 하는 버킷을 주목
        3. 버킷이 참조하는 연결 리스트를 맨 앞부터 스캔함
    => 키와 같은 값을 찾으면 그 노드를 연결 리스트로부터 연결 해제(삭제), 못 찾으면 삭제 실패

  - dump() 함수
    - 해시 테이블의 각 인덱스마다 연결된 모든 노드의 키와 값을 출력

<br><br><br>

## 그리디 알고리즘
- 대표적인 예시 : 최소 개의 동전으로 거스름돈을 주는 경우
  - 가장 큰 단위 동전부터 차례대로 확인한다
- 큰 단위가 작은 단위의 배수인 경우 그리디 알고리즘을 사용하는 게 합리적일 수 있음

<br><br><br>

## 완전 탐색
- 가능한 경우의 수를 모두 탐색하는 방법
- 확인해야할 데이터의 수가 100만개 이하일 때 사용하는 것이 적절함


